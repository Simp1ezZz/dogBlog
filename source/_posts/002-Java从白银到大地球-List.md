---
title: 002-Java从白银到大地球-List
date: 2021-05-16 15:56:15
tags:
  - Java
  - 从白银到大地球
  - 集合
  - List
  - ArrayList
  - LinkedList
  - Vector
category: 学习
cover: https://gitee.com/SimpleZzz/pic/raw/master/img/%E7%99%BD%E9%93%B6%20%E4%B8%80%20I.png
---

# Java从白银到大地球-List

{% note primary flat %}今天来说一说List集合，介绍一下其中常用的方法是如何实现的，比较一下各种List之间的优缺点，如何选用合适的List{% endnote %}



## 1. List的主要三个子类

- ArrayList------底层数据结构是数组，线程不安全
- LinkedList-----底层数据结构是双向链表，线程不安全
- Vector---------底层数据结构是数组，线程安全

> 可以看出List的三个子类主要的区别是底层数据结构的不同，分别使用了数组和双向链表，其次就是线程安全的不同。所以为了后面更好地介绍三个子类，我们先来**简单介绍一下数组和链表这两个数据结构**。

---

## 2. 数组和链表

### 2.1 数组

- 首先给出数组的定义：

	> **数组**（Array）是有序的元素序列。 若将有限个类型相同的变量的**集合**命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。这些有序排列的同类数据元素的集合称为数组。
	>
	> <p style="text-align:right">-----取自：百度百科</p>

- 简而言之就是`用来存放相同类型元素的一种有序集合，可以通过元素的下标，即元素在该集合中的位置来直接获取到该元素`。

- 现定义一个数组`int[] arr = [11,22,33,44,55]`，结构如下图所示，要求实现如下几个需求。

    ![数组结构图](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/%E6%95%B0%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

    - 如何获取到`33`这个元素？
        1. a[2]
    - 如果要原地删除`55`，也就是末尾这个元素，该怎么做？（原地即为在原数组上操作而不用创建新数组）
        1. 直接将数组长度标识减一
    - 如果要原地删除`33`这个元素，该怎么做？
        1. 元素`33`之前的元素不动
        2. 将元素`33`之后的元素下标分别减一，即向前移动一位
        3. 将数组长度标识减一
    - 如果要在`55`之后，也就是末尾新增一个元素，该怎么做?（默认数预分配组空间足够）
        	1. 将数组长度标识加一
         	2. 把新增元素赋值给当前末尾元素
    - 如果要在`33`之后新增一个元素，该怎么做？
        1. 将数组长度标识加一
        2. 将现在倒数第二个元素至`33`之后的元素右移一个位置，即下标加一（注意此时应从后往前分别移动元素）
        3. 将新增的元素赋值给`33`之后的位置

---

### 2.2 链表

- 链表定义

    > 链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。
    >
    > <p style="text-align:right">-----取自：百度百科</p>

- 简单的说就是`把每个元素放在一个节点里从头到尾连接起来，连接方式就是每个节点存储了下一个节点的地址,可以通过这样不断寻找下一个节点来找到整个链表`

- 相同的，我们也定义一个链表，结构如下图所示，提出和数组相同的需求：

    ![链表示意图](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

    - 如何获取到`33`这个元素？
        1. 根据第一个节点存储的地址找到元素`22`所在节点
        2. 再次根据当前节点存储的地址找到元素`33`所在节点
        3. 取当前节点存储的元素值
    - 如果要原地删除`55`，也就是末尾这个元素，该怎么做？（原地即为在原链表上操作而不用创建新链表）
        1. 一前一后两个指针遍历链表，直至前面的指针找到了`55`元素的节点，而此时后面的指针正好指向了`55`前一个节点，也就是`44`
        2. 将`44`元素节点存储的下一个节点地址替换为`55`节点存储的地址，因为`55`节点是末尾，所以其实就是替换成了`NULL`
        3. 释放`55`节点内存
    - 如果要原地删除`33`这个元素，该怎么做？
        1. 一前一后两个指针遍历链表，直至前面的指针找到了`33`元素的节点，而此时后面的指针正好指向了`33`前一个节点，也就是`22
        2. 将`22`元素节点存储的下一节点地址替换为`33`节点存储的地址，也就是将`22`元素和`44`元素相连接了
        3. 释放`33`节点内存
    - 如果要在`55`之后，也就是末尾新增一个元素，该怎么做?
        1. 遍历链表，找到`55`节点
        2. 新建一个节点，节点元素为新增的元素，存储的地址设置`55`节点存储的地址，因为其为尾结点，所以其实是`NULL`
        3. 将`55`节点存储的地址替换为新建节点的地址
    - 如果要在`33`之后新增一个元素，该怎么做？
        1. 遍历链表，找到`33`节点
        2. 新建一个节点，节点元素为新增的元素，存储的地址设置为`33`节点存储的地址，也就是`44`
        3. 将`33`节点存储的地址替换为新建节点的地址，相当于将`33`->`新节点`->`44`连接起来

---

### 2.3 数组和链表的区别

- 查找时
    - 数组直接通过下标即可查找到所需元素，时间复杂度为O(1)。
    - 链表需要从头开始遍历，直至找到所需元素，时间复杂度为O(n)。
    - **明显数组在查询时效率要优于链表。**
- 在末尾新增删除元素
    - 数组在末尾新增元素，只需要将元素插入即可，删除末尾元素，也只需要删除对应元素即可。
    - 链表在末尾新增删除元素，首先需要遍历到末尾，然后将节点插入到末尾，或者删除末尾节点。
    - **链表由于需要一个遍历到末尾的过程，所以说没有数组效率高。** *PS:当然这里针对的是单链表，其他例如循环链表可以直接一步遍历到尾结点，那么其效率应该是持平的*

- 在其余地方新增或删除元素
    - 数组在除末尾新增元素时，需要将新增元素位置后所有元素后移，相同的，删除元素时，需要将删除元素节点后的所有元素前移
    - 链表在其余地方删除元素时，首先需要遍历到该地方，然后修改指针指向即可，新增元素时，也是遍历到该地方，然后新建节点，修改指针即可
    - **链表和数组效率的区别体现在链表需要遍历至对应节点，而数组需要移动大量元素，而移动元素是要比遍历更加耗时的，所以该情况下链表的效率比数组要高**

> 总结一下就是数组在查询时效率高，而链表在增删时效率高

---

## 3. ArrayList

### 3.1 ArrayList中的属性字段

我们直接来看ArrayList的源码：

![](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E5%B1%9E%E6%80%A7%E6%BA%90%E7%A0%81%E8%A7%A3%E9%87%8A.png)

从源码中可以明显看出，ArrayList的底层实现是对象数组，而且该数组会在容量不够时进行一个**扩容**的操作，所以才可以动态增长长度。不指定初始化容量时默认初始化容量为10。

### 3.2 构造方法

上面的属性我们可以了解到在创建ArrayList的时候是可以指定初始化大小的，下面让我们看一看源码中构造方法是如何实现的：

- ArrayList一共有三种构造方法，分别是无参构造、一个int类型参数的构造和一个Collection类型参数的构造。

    ![](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E4%B8%89%E7%A7%8D%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png)

- 无参构造函数

    ![](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E6%97%A0%E5%8F%82%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

- int类型参数的构造函数

    ![](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E7%9A%84int%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0.png)

- Collection类型参数的构造函数

    ![](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E7%9A%84Collection%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png)

> 可以看出在创建ArrayList时如果不指定容量，则默认初始化容量为10，可以通过传入int类型的参数来制定初始化大小，也可以通过传入Collection集合来将整个集合在初始化时放入ArrayList中

### 3.3 add方法

- add方法一共有两种，分别是在最后插入和在指定位置插入。
- 首先是单个参数的add方法，该方法是用来在ArrayList末尾插入元素，平时是最经常使用的。

![ArrayList单个参数的add方法](https://my-pic-picgo.oss-cn-shanghai.aliyuncs.com/ArrayList%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%9A%84add%E6%96%B9%E6%B3%95.png)

- 第二个是两个参数的add方法，就是多出一个插入位置的参数，用来插入到任意位置。

    
